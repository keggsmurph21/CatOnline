#!/usr/bin/env node

const chalk  = require( 'chalk' );

const game  = require( '../tests/example/games.json' )[1]; // eventually make
const user  = require( '../tests/example/users.json' )[0]; //these passable somehow

const FUNCS  = require( '../app/funcs.js' );
const LOGIC  = require( '../app/logic.js' );
const CONFIG = require( '../config/catan.js' );
const STATES = require( '../config/states.js');

const error = function(msg) { console.log(chalk.red(msg)); process.exit(1); }
const warn =  function(msg) { console.log(chalk.keyword('orange')(msg)); }

require('readline')
  .createInterface({
    input: process.stdin,
    output: process.stdout,
    terminal: false
  })
  .on('line', function(line) {
    parseInput(line);
  });

function getAdjacentGameStates() {
  for (let p in game.state.players) {
    let flags = LOGIC.checkFlags(game,p);
    let adjacents = CONFIG.getAdjacentGameStates(flags);
    console.log(adjacents);
  }
}

function validatePlayerID(id) {
  let int = parseInt(id);
  if (isNaN(int))
    error('unable to parse player id `'+id+'`');
  if (int < 0 || game.state.players.length <= int)
    error('player id out of bounds `'+id+'`');
  return int;
}

function parseCommand(player, args) {
  if (!args.length)
    return true;

  let command = args[0];

  switch (command) {
    case ('exec'):
      let edge = args[1]; // undefined if not enough args given
      if (edge === undefined)
        warn('not enough arguments for exec');
      if (!LOGIC.validateEdgeIsAdjacent(game, player, edge)) {
        warn('player '+player+' is not adjacent to edge `'+edge+'`');
      } else {
        edge = STATES.edges[edge];
        console.log(edge);
      }
      break;
  }
}

function parseInput(line) {

  console.log(chalk.green('\n >> '+line));

  let words = line.split(' '),
    command = words[0];

  switch (command) {
    case ('do'):
      let player_id = validatePlayerID(words[1]);
      parseCommand(player_id, words.slice(2));
      break;
    case ('ga' || 'get-adj'):
      getAdjacentGameStates();
      break;
    default:
      warn('unrecognized command `'+command+'`');
  }
}
