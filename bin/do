#!/usr/bin/env node
/*
 * /scripts/do
 *
 * Kevin Murphy
 * 29 March 2018
 *
 * Reads a list of commands from standard input and executes them in order.
*/

const argv   = process.argv.slice(2);
const chalk  = require( 'chalk' );
const exec   = require('child_process').exec;
const fs     = require('fs');
const read   = require('readline');

const CONFIG = require( '../config/catan' );
const FUNCS  = require( '../app/funcs' );
const GAMES  = require( '../tests/example/games' );
const LOGIC  = require( '../app/logic' );
const SOCKETS= require( '../app/sockets' );
const STATES = require( '../config/states' );
const USERS  = require( '../tests/example/users' );

const error  = function(msg) { console.log(chalk.red(msg)); }

var game=null, user=null;

function getPlayerStringByID(id) {
  let player = game.state.players[id];
  return 'player '+id+': '+player.lobbyData.name;
}

function validatePlayerID(id) {
  let int = parseInt(id);
  if (isNaN(int))
    throw Error('unable to parse player id `'+id+'`');
  if (int < 0 || game.state.players.length <= int)
    throw Error('player id out of bounds `'+id+'`');
  return int;
}

function loadGame(id=0) {
  return Object.assign({}, GAMES[id]);
}

function loadUser(id=0) {
  var obj = Object.assign({}, USERS[id]);
  obj.id = obj._id['$oid'];
  return obj;
}

function parseInput(line) {

  try {

    let words = line.split(' '),
      command = words[0],
      args    = words.slice(1);

    if (command[0] === '#') // comment
      return
    console.log(chalk.green(' >> '+line));

    switch (command) {
      case ('do'):
        let player_id = validatePlayerID(args[0]);
        switch (args[1]) {
          case ('exec'):
          case ('force'):
            let edge = args[2]; // undefined if not enough args given
            let validate = (args[1]=='exec');

            if (!LOGIC.validateEdgeIsAdjacent(game, player_id, edge))
              return error('player '+player_id+' is not adjacent to edge `'+edge+'`');
            LOGIC.executeEdge(game, player_id, edge, args.slice(3), validate);
            break;

          default:
            error('unrecognized arguments:', args);
        }
        break;

      case ('get'):
        let func = function() { return ''; };
        switch (args[0]) {
          case ('all'):
            func = function(game, p) {
              return '\n  vertex:\t'+LOGIC.getFlags(game, p).vertex
                +'\n  adjacents:\t'+ LOGIC.getAdjacentGameStates(game, p)
                +'\n  settlements:\t'+ game.state.players[p].settlements
                +'\n  roads:\t'+ game.state.players[p].roads
                +'\n  resources:\t'+ JSON.stringify(game.state.players[p].resources);
            }
            break;
          case ('adjs'):
            func = LOGIC.getAdjacentGameStates;
            break;
          case ('flags'):
            func = LOGIC.getFlags;
            break;
          case ('resources'):
            func = function(game, p) {
              return JSON.stringify(game.state.players[p].resources);
            }
            break;
          case ('roads'):
            func = function(game, p) {
              return game.state.players[p].roads;
            }
            break;
          case ('settlements'):
            func = function(game, p) {
              return game.state.players[p].settlements;
            }
            break;
          case ('vertices'):
            func = function(game, p) {
              return LOGIC.getFlags(game, p).vertex;
            }
            break;
          default:
            error('unrecognized arguments:', args);
        }

        console.log('[turn: '+game.state.turn+']');
        for (let p in game.state.players) {
          let pstr = getPlayerStringByID(p);
          let data = func(game, p);
          console.log(pstr, '\t', data);
        }
        break;

      case ('check'):
        switch (args[0]) {
          case ('waiting'):
            let waiting = game.state.waiting;
            console.log('for: ', waiting.forWho.map(o=>o.name).join(', '));
            console.log('what:', waiting.forWhat);
            break;
          default:
            error('unrecognized arguments:', args);
        }
        break;

      case ('exit'):
        process.exit(0);
        break;

      case ('read'):
        read
          .createInterface({
            input: fs.createReadStream('tests/'+args[0]),
            output: process.stdout,
            terminal: false
          })
          .on('line', parseInput);
        break;

      case ('reset'):
        game = loadGame();
        user = loadUser();
        break;

      default:
        error('unrecognized command:', command);
    }
  } catch (e) {
    error(e);
  }
}

function parse(args) {

  game = loadGame();
  user = loadUser();

  read
    .createInterface({
      input: (args.length
        ? fs.createReadStream('tests/'+args[0])
        : process.stdin),
      output: process.stdout,
      terminal: false
    })
    .on('line', parseInput);

}

parse(argv);
