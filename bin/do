#!/usr/bin/env node
/*
 * /scripts/do
 *
 * Kevin Murphy
 * 29 March 2018
 *
 * Reads a list of commands from standard input and executes them in order.
*/

const argv   = process.argv.slice(2);
const chalk  = require( 'chalk' );
const exec   = require( 'child_process' ).exec;
const fs     = require( 'fs' );
const read   = require( 'readline' );

const CONFIG = require( '../config/catan' );
const FUNCS  = require( '../app/funcs' );
const GAMES  = require( '../tests/example/games' );
const LOGIC  = require( '../app/logic' );
const SOCKETS= require( '../app/sockets' );
const STATES = require( '../config/states' );
const USERS  = require( '../tests/example/users' );

const error  = function(msg) { console.log(chalk.red(msg)); }

var game=null, user=null, suite='default', quiet=false;

function getPlayerStringByID(id) {
  let player = game.state.players[id];
  return 'player '+id+': '+player.lobbyData.name;
}

function validatePlayer(id) {
  let int = parseInt(id);
  if (isNaN(int))
    throw Error('unable to parse player id `'+id+'`');
  if (int < 0 || game.state.players.length <= int)
    throw Error('player id out of bounds `'+id+'`');
  return int;
}

function loadGame(id=0) {
  return Object.assign({}, GAMES[id]);
}

function loadUser(id=0) {
  var obj = Object.assign({}, USERS[id]);
  obj.id = obj._id['$oid'];
  return obj;
}

function parseInput(line, callback=()=>{}) {

  try {

    let words = line.split(' '),
      command = words[0],
      args    = words.slice(1);

    if (command[0] === '#') // comment
      return

    if (!quiet)
      console.log(chalk.green(' >> '+line));


    switch (command) {
      case ('do'):
        let player_id = validatePlayer(args[0]);
        switch (args[1]) {
          case ('exec'):
          case ('force'):
            let edge = args[2]; // undefined if not enough args given
            args = (args[1]=='exec'
              ? LOGIC.validateArguments(player_id, edge, args.slice(3))
              : args.slice(3).map(a=>parseInt(a)));

            if (!LOGIC.validateEdgeIsAdjacent(game, player_id, edge))
              return error('player '+player_id+' is not adjacent to edge `'+edge+'`');
            LOGIC.executeEdge(game, player_id, edge, args);
            break;

          default:
            error('unrecognized arguments:', args);
        }
        break;

      case ('get'):
        let func = function() { return ''; };
        switch (args[0]) {
          case ('all'):
            func = function(game, p) {
              return {
                vertex:       LOGIC.getFlags(game, p).vertex,
                adjacents:    LOGIC.getAdjacentGameStates(game, p),
                settlements:	game.state.players[p].settlements,
                roads:	      game.state.players[p].roads,
                resources:	  game.state.players[p].resources }
            }
            break;
          case ('adj'):
          case ('adjs'):
          case ('adjacents'):
            func = LOGIC.getAdjacentGameStates;
            break;
          case ('flags'):
            func = LOGIC.getFlags;
            break;
          case ('players'):
            func = (game,p) => { return game.state.players[p]; };
            break;
          case ('resources'):
            func = function(game, p) {
              return game.state.players[p].resources;
            }
            break;
          case ('roads'):
            func = function(game, p) {
              return game.state.players[p].roads;
            }
            break;
          case ('settlements'):
            func = function(game, p) {
              return game.state.players[p].settlements;
            }
            break;
          case ('vertices'):
            func = function(game, p) {
              return LOGIC.getFlags(game, p).vertex;
            }
            break;
          default:
            error('unrecognized arguments:', args);
        }

        console.log('[turn: '+game.state.turn+']');
        let data = [];
        for (let p=0; p<game.state.players.length; p++) {
          data.push({
            full: game.state.players,
            func: func(game, p)
          })
          //let pstr = getPlayerStringByID(p);
          //let data = func(game, p);
          //console.log(pstr, '\t', data);
        }
        console.log(JSON.stringify(data.map(p=>p.func), null, 2));
        break;

      case ('check'):
        switch (args[0]) {
          case ('waiting'):
            let waiting = game.state.waiting;
            console.log('for: ', waiting.forWho.map(o=>o.name).join(', '));
            console.log('what:', waiting.forWhat);
            break;
          case ('history'):
            console.log(JSON.stringify(game.state.history, null, 3));
            break;
          case ('trade'):
            console.log(game.state.currentTrade);
            break;
          default:
            error('unrecognized arguments:'+args);
        }
        break;

      case ('exit'):
        process.exit(0);
        break;

      case ('raise'):
        error(suite+' raises '+args.join(' '));
        break;

      case ('read'):
        suite = args[0];
        read
          .createInterface({
            input: fs.createReadStream('tests/commands/'+args[0]),
            output: process.stdout,
            terminal: false
          })
          .on('line', parseInput);
        break;

      case ('reset'):
        game = loadGame();
        user = loadUser();
        break;

      case ('set'):
        let argstring = args.slice(1).join(' ');
        if (!argstring.length)
          return error('expected JSON arguments');
        let values = JSON.parse(JSON.stringify(argstring));
        console.log('values', JSON.stringify(values));

        switch (args[0]) {
          case ('state'):
            game.state = values;
            break;
          case ('board'):
            game.board = values
            break;
          case ('player'):
            argstring = args.slice(2).join(' ');
            values = (argstring.length ? JSON.parse(argstring) : {});
            if (args[1]==='all') {
              for (let p=0; p<game.state.players.length; p++) {
                game.state.players[p] = values;
              }
            } else {
              let p = validatePlayer(args[1]);
              game.state.players[p] = values;
            }
            break;
          default:
            error('unrecognized key: '+args[1]);
        }
        break;

      default:
        error('unrecognized command: '+command);
    }
  } catch (e) {
    error(e);
  }
}

function listen(path) {

  game = loadGame();
  user = loadUser();

  read
    .createInterface({
      input: (path
        ? fs.createReadStream(path)
        : process.stdin),
      output: process.stdout,
      terminal: false
    })
    .on('line', parseInput);

}

if (require.main === module)
  listen(argv.length ? 'tests/commands/'+argv[0] : null);

module.exports = parseInput;
module.exports.setup = function(args) {
  game = args.g || loadGame();
  user = args.u || loadUser();
  quiet= (args.quiet===undefined ? quiet : args.quiet);
}
