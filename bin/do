#!/usr/bin/env node
/*
 * /scripts/do
 *
 * Kevin Murphy
 * 29 March 2018
 *
 * Reads a list of commands from standard input and executes them in order.
*/

const chalk  = require( 'chalk' );
const exec   = require('child_process').exec;
const argv   = process.argv.slice(2);

const game   = require( '../tests/example/games.json' )[1]; // eventually make
const user   = require( '../tests/example/users.json' )[0]; //these passable somehow

const FUNCS  = require( '../app/funcs.js' );
const LOGIC  = require( '../app/logic.js' );
const CONFIG = require( '../config/catan.js' );
const STATES = require( '../config/states.js');

const error  = function(msg) { console.log(chalk.red(msg)); process.exit(1); }
const warn   =  function(msg) { console.log(chalk.keyword('orange')(msg)); }

function getAdjacentGameStates() {
  for (let p in game.state.players) {
    let adjacents = LOGIC.getAdjacentGameStates(game,p);
    console.log(adjacents);
  }
}

function validatePlayerID(id) {
  let int = parseInt(id);
  if (isNaN(int))
    error('unable to parse player id `'+id+'`');
  if (int < 0 || game.state.players.length <= int)
    error('player id out of bounds `'+id+'`');
  return int;
}

function parseCommand(player, args) {
  if (!args.length)
    return true;

  let command = args[0];

  switch (command) {
    case ('exec'):
      let edge = args[1]; // undefined if not enough args given
      if (edge === undefined)
        warn('not enough arguments for exec');
      if (!LOGIC.validateEdgeIsAdjacent(game, player, edge)) {
        warn('player '+player+' is not adjacent to edge `'+edge+'`');
      } else {
        edge = STATES.edges[edge];
        LOGIC.executeEdge(edge);
        //edge.execute(null,null);
      }
      break;
  }
}

function parseInput(line) {

  console.log(chalk.green(' >> '+line));

  let words = line.split(' '),
    command = words[0];

  switch (command) {
    case ('do'):
      let player_id = validatePlayerID(words[1]);
      parseCommand(player_id, words.slice(2));
      break;
    case ('ga' || 'get-adj'):
      getAdjacentGameStates();
      break;
    default:
      warn('unrecognized command `'+command+'`');
  }
}

function parse(args) {

  require('readline')
    .createInterface({
      input: (args.length
        ? require('fs').createReadStream('tests/'+args[0])
        : process.stdin),
      output: process.stdout,
      terminal: false
    })
    .on('line', function(line) {
      parseInput(line);
    });
    
}

parse(argv);
