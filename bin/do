#!/usr/bin/env node
/*
 * /scripts/do
 *
 * Kevin Murphy
 * 29 March 2018
 *
 * Reads a list of commands from standard input and executes them in order.
*/

const chalk  = require( 'chalk' );
const exec   = require('child_process').exec;
const argv   = process.argv.slice(2);

const FUNCS  = require( '../app/funcs.js' );
const LOGIC  = require( '../app/logic.js' );
const CONFIG = require( '../config/catan.js' );
const STATES = require( '../config/states.js');

const error  = function(msg) { console.log(chalk.red(msg)); process.exit(1); }
const warn   = function(msg) { console.log(chalk.keyword('orange')(msg)); }

var game, user;

function getPlayerStringByID(id) {
  let player = game.state.players[id];
  return 'player '+id+': '+player.lobbyData.name;
}

function validatePlayerID(id) {
  let int = parseInt(id);
  if (isNaN(int))
    error('unable to parse player id `'+id+'`');
  if (int < 0 || game.state.players.length <= int)
    error('player id out of bounds `'+id+'`');
  return int;
}

function load() {
  game   = require( '../tests/example/games.json' )[1]; // eventually make
  user   = require( '../tests/example/users.json' )[0]; //these passable somehow
}

function parseInput(line) {

  console.log(chalk.green(' >> '+line));

  let words = line.split(' '),
    command = words[0],
    args    = words.slice(1);

  switch (command) {
    case ('do'):
      let player_id = validatePlayerID(args[0]);
      switch (args[1]) {
        case ('exec'):
          let edge = args[2]; // undefined if not enough args given
          if (edge === undefined) {
            warn('not enough arguments for exec');
          } else if (!LOGIC.validateEdgeIsAdjacent(game, player_id, edge)) {
            warn('player '+player_id+' is not adjacent to edge `'+edge+'`');
          } else {
            LOGIC.executeEdge(game, player_id, edge, args.slice(3));
          }
          break;
        default:
          warn('unrecognized arguments:', args);
      }
      break;

    case ('get'):
      let func = function() { return ''; };
      switch (args[0]) {
        case ('all'):
          func = function(game, p) {
            return LOGIC.getFlags(game, p).vertex + '\t'
              + LOGIC.getAdjacentGameStates(game, p);
          }
          break;
        case ('adjs'):
          func = LOGIC.getAdjacentGameStates;
          break;
        case ('flags'):
          func = LOGIC.getFlags;
          break;
        case ('vertices'):
          func = function(game, p) {
            return LOGIC.getFlags(game, p).vertex;
          }
          break;
        default:
          warn('unrecognized arguments:', args);
      }

      for (let p in game.state.players) {
        let pstr = getPlayerStringByID(p);
        let data = func(game, p);
        console.log(pstr, '\t', data);
      }

      break;

    case ('reset'):
      load();
      break;

    default:
      warn('unrecognized command:', command);
  }
}

function parse(args) {

  load();

  require('readline')
    .createInterface({
      input: (args.length
        ? require('fs').createReadStream('tests/'+args[0])
        : process.stdin),
      output: process.stdout,
      terminal: false
    })
    .on('line', function(line) {
      parseInput(line);
    });

}

parse(argv);
